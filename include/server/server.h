#ifndef SERVER_H
#define SERVER_H

#include <stdint.h>
#include <address.h>

const uint32_t ProtocolId = 0x12341651;
const int MaxPacketSize = 1200;
const int MaxClients = 32;
const int ServerPort = 50000;
const int ClientPort = 60000;
const int ChallengeHashSize = 1024;
const float ChallengeSendRate = 0.1f;
const float ChallengeTimeOut = 10.0f;
const float ConnectionRequestSendRate = 0.1f;
const float ConnectionChallengeSendRate = 0.1f;
const float ConnectionResponseSendRate = 0.1f;
const float ConnectionConfirmSendRate = 0.1f;
const float ConnectionKeepAliveSendRate = 1.0f;
const float ConnectionRequestTimeOut = 5.0f;
const float ChallengeResponseTimeOut = 5.0f;
const float KeepAliveTimeOut = 10.0f;
const float ClientSaltTimeout = 1.0f;

uint64_t GenerateSalt()
{
    return ((uint64_t(rand()) << 0) & 0x000000000000FFFFull) | ((uint64_t(rand()) << 16) & 0x00000000FFFF0000ull) | ((uint64_t(rand()) << 32) & 0x0000FFFF00000000ull) | ((uint64_t(rand()) << 48) & 0xFFFF000000000000ull);
}

enum PacketTypes {
    PACKET_CONNECTION_REQUEST, // client requests a connection.
    PACKET_CONNECTION_DENIED, // server denies client connection request.
    PACKET_CONNECTION_CHALLENGE, // server response to client connection request.
    PACKET_CONNECTION_RESPONSE, // client response to server connection challenge.
    PACKET_CONNECTION_KEEP_ALIVE, // keep alive packet sent at some low rate (once per-second) to keep the connection alive
    PACKET_CONNECTION_DISCONNECT, // courtesy packet to indicate that the other side has disconnected. better than a timeout
    CLIENT_SERVER_NUM_PACKETS
};

struct ServerChallengeEntry {
    uint64_t client_salt; // random number generated by client and sent to server in connection request
    uint64_t challenge_salt; // random number generated by server and sent back to client in challenge packet
    double create_time; // time this challenge entry was created. used for challenge timeout
    double last_packet_send_time; // the last time we sent a challenge packet to this client
    Address address; // address the connection request came from
};

struct ServerChallengeHash {
    int num_entries;
    uint8_t exists[ChallengeHashSize];
    ServerChallengeEntry entries[ChallengeHashSize];

    ServerChallengeHash() { memset(this, 0, sizeof(ServerChallengeHash)); }
};

uint64_t CalculateChallengeHashKey(const Address& address, uint64_t clientSalt, uint64_t serverSeed)
{
    char buffer[256];
    const char* addressString = address.ToString(buffer, sizeof(buffer));
    const int addressLength = (int)strlen(addressString);
    return murmur_hash_64(&serverSeed, 8, murmur_hash_64(&clientSalt, 8, murmur_hash_64(addressString, addressLength, 0)));
}

struct ServerClientData {
    Address address;
    uint64_t clientSalt;
    uint64_t challengeSalt;
    double connectTime;
    double lastPacketSendTime;
    double lastPacketReceiveTime;

    ServerClientData()
    {
        clientSalt = 0;
        challengeSalt = 0;
        connectTime = 0.0;
        lastPacketSendTime = 0.0;
        lastPacketReceiveTime = 0.0;
    }
};

Packet* ReceivePacket(Socket* socket, PacketFactory* packetFactory, Address& address)
{
    uint8_t packetData[MaxPacketSize];

    int packetBytes = socket->ReceivePacket(address, packetData, MaxPacketSize);

    if (!packetBytes)
        return NULL;

    protocol2::PacketInfo info;
    info.protocolId = ProtocolId;
    info.packetFactory = packetFactory;

    return protocol2::ReadPacket(info, packetData, packetBytes, NULL);
}

typedef struct Server {
    Socket* m_socket; // socket for sending and receiving packets.

    PacketFactory* m_packetFactory; // packet factory for creating and destroying packets.

    uint64_t m_serverSalt; // server salt. randomizes hash keys to eliminate challenge/response hash worst case attack.

    int m_numConnectedClients; // number of connected clients

    bool m_clientConnected[MaxClients]; // true if client n is connected

    uint64_t m_clientSalt[MaxClients]; // array of client salt values per-client

    uint64_t m_challengeSalt[MaxClients]; // array of challenge salt values per-client

    Address m_clientAddress[MaxClients]; // array of client address values per-client

    ServerClientData m_clientData[MaxClients]; // heavier weight data per-client, eg. not for fast lookup

    ServerChallengeHash m_challengeHash;

} Server;




#endif